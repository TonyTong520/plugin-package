# 模块化

## 简单的使用js文件作为模块的缺陷
1. 全局变量污染
2. 引用js文件的时候，次序非常重要，而且比较麻烦


## 模块化的优势
1. 可以将公共的部分定义成模块，方便复用
2. 解决全局变量污染的问题
3. 模块之间的依赖关系，非常明确，而且在应用模块的时候，根本不需要考虑依赖的先后顺序问题。


## 前端模块化

### 模块化的标准
1. CommonJS: 是一个模块化的标准。Node.js在使用的一个模块化的标准

2. AMD: Async Module Definition, 在CommonJS基础上衍生出来的适用于前端开发中的模块化标准

AMD. 尽早将所有的模块全部加载进来  require.js

3. CMD: Common Module Definition
在CommonJS基础上衍生出来的适用于前端开发中的模块化标准

CMD. 用到之的时候再加载， as lazy as possible   sea.js

AMD没有明显的BUG，CMD明显没有BUG


## 模块化的是实现（require.js）
require.js 只是一个js文件，这个js文件可以帮助我们实现前端模块化，他遵循的标准就是AMD标准。

### 定义模块
```js
define(function(){
	//模块中所有的内容
	console.log("Hello, 我是一个模块");
})
```

### 引用模块
```js
require(["模块的名称"], function(){
	
})
```

### 注意事项
如果模块只是执行一些代码实现指定的功能，那么直接引用该模块，功能即可实现。
但是如果模块的存在是为了给我们提供一些方法，对象，其他的内容让我们使用的话，就需要给这个模块一个产出，使用return语句将要提供给别人使用的内容进行返回，使用该模块的使用，需要在require的第二个参数的函数中书写一个形参来接收这个内容，就能达到使用的效果了！

## 模块依赖项的处理
如果定义一个模块的时候，这个模块要依赖于其他模块来实现，那么我们需要给这个模块指定依赖项

define(["依赖项1","依赖项2"..."依赖项N"], function(){
	//模块的功能代码
})


如果模块的依赖项有给模块提供内容使用，那么需要在当前模块的回调函数中添加形参来接收依赖项模块的返回值，这里的形参和依赖项是一一对应的，如果存在好多依赖项，有的依赖项有产出，有的没有，那我们一般会将所有有产出的依赖项放在前面，没有的放在后面，这样可以省略掉没有产出模块的形参


## requirejs的入口文件设置
### data-main
可以给请求requirejs的script标签设置一个data-main属性，这个属性中放的是一个文件的路径，在requirejs加载完毕之后，会自动去执行data-main这个路径中指向的文件中的js代码！


**data-main中的内容是异步加载的，如果下面有要基于data-main的功能实现的内容，那么requirejs不能保证data-main是在下面的内容之前执行的**


## 模块路径查找的问题
1. 如果直接在html文件中书写script标签，在标签内使用require来加载某个模块，那么会以当前的这个html文件作为参照，去找相对路径

2. 如果我们是在入口文件中使用require加载的模块，那么这个时候是参照data-main指定的这个入口文件所在的目录来找模块的路径的！

3. 如果通过config指定了requirejs的baseUrl，那么所有的模块路径查找都会以这个baseUrl作为基础，去查找


## requirejs可以通过config来配置一些内容
### baseUrl
require.config({
	//所有模块的路径查找，都会以这个baseUrl指定的路径为基础
	//一般情况下就是找所有模块都能够共享的目录，作为baseUrl
	baseUrl: "",

	//paths属性可以为每一个模块配置别名
	//以后在使用模块的时候，不需要再去写那么长的真实路径了，而直接使用别名即可
	paths: {
		//键： 别名名称
		//值： 真实的模块路径
		"xm": "modules1/modules2/modules3/moduleXM" 
	}
});

